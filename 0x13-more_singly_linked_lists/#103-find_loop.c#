#include "lists.h"
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
/**
 * print_listint_safe - function prints safe
 * Return:n
 * @head: the list
 */
listint_t *find_listint_loop(listint_t *head)
{
	listint_t *tortoise = head;
	listint_t *hare = head;

	while (tortoise && hare && hare->next)
	{
		tortoise = tortoise->next;
		hare = hare->next->next;

		if (tortoise == hare)
		{
			hare = head;
			while (tortoise != hare)
			{
				hare = hare->next;
				tortoise = tortoise->next;
			}

			printf("Loop starts at address: %p\n", (void *)tortoise);
			return tortoise;
		}
	}

	return NULL;
}
In this corrected version:

We use two pointers, tortoise and hare, to traverse the linked list. tortoise moves one step at a time, and hare moves two steps at a time.

	If there is a cycle in the linked list, the hare will eventually catch up to the tortoise, indicating the presence of a cycle.

	If a cycle is detected, we reset the hare to the head of the linked list and move both tortoise and hare one step at a time until they meet. The meeting point will be the start of the cycle.

	We print the address of the node where the cycle starts using printf("Loop starts at address: %p\n", (void *)tortoise);.

We then return the node where the cycle starts (tortoise).

	If no cycle is detected, we return NULL, indicating that there is no loop in the linked list.

																       With this corrected approach, the function will now correctly find the loop in the linked list, print the address of the node where the duplicate starts, and return that node as required.





																       
